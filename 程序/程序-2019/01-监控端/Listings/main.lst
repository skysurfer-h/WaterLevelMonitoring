C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Main\main.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\STC8_I2C_OLED_
                    -Example;.\OLED_DSP;.\User_DSP;.\Common;.\Main) DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //2018.10.16 侯
   2          #include <stc8fxx.h>
   3          #include "intrins.h"
   4          #include "main.h"
   5          #include "i2c.h"
   6          #include "SSD1306.h"
   7          #include "GUI.h"
   8          #include "font.h"
   9          #include "delay.h"
  10          
  11          #define uchar unsigned char
  12          #define uint unsigned int
  13          
  14          void oled_display(void);
  15          void key_scan();
  16          void deal_date(); //数据处理
  17          void buzzer_mode(uchar mode);//蜂鸣器
  18          uint buzzer_count=0;
  19          uchar buzzer_step=1;
  20          
  21          //菜单
  22          uchar DIST[2]={0xe9,0x01};//489
  23          uint DIST_temp=200;
  24          uint water_height=10,pot_height=1200;
  25          uchar water_height_score=50;
  26          
  27          uchar cou=0,sec=0,min=0,SendDate_count=0;
  28          uchar ruler_online_state=0;  //超声波测距在线标志
  29          uint  ruler_online_time=0; //水泵在线计时
  30          uchar pump_online_state=0;   //水泵在线标志
  31          uint  pump_online_time=0;
  32          
  33          uchar pump_power=0;//水泵启停标志
  34          uchar pump_power_real=0;//远程端  水泵工作状态回传   
  35          
  36          uchar down_state=0;  //数据下载标志
  37          uint down_state_time=0; //在线计时
  38          
  39          uchar mode_state=0; //模式 0 自动   1手动
  40          uchar message_state=1;//状态提示栏
  41          uchar menu=1;//菜单 1 主页    2 设置―1    3  设置-2
  42          uchar pump_auto_sign=0;//自动抽水标志  1则 抽水前不提醒 全自动
  43          uchar set_state=1;//设置菜单内滚动标志
  44          uint DIST_H=150;DIST_L=600;//水位上下限
  45          
  46          uchar pump_error_time_set=30;//水泵异常延时时间设定值  初始化为30秒  30秒水位未上升则视为异常
  47          uchar pump_error_time=0;   //水泵异常延时时间
  48          uint  DIST_last=0;       
  49          uint  pump_error_count=0;
  50          uchar buzzer_off=0;//消音标志
  51          
  52          uchar send_add=0;//发送数据 目标设备地址
  53          uchar add=0;
  54          
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 2   

  55          sbit key1=P1^6;
  56          sbit key2=P1^7;
  57          sbit key3=P5^4;
  58          sbit buzzer=P1^2;
  59          sbit test=P3^6;
  60          sbit set_jdy40=P1^3;
  61          //sbit key5=P3^6;
  62          void oled_display(void);
  63          void SendDate();
  64          void RecDate();
  65          void time_init (void);
  66          void state_deal();
  67          /*******************************uart*************************************/
  68          bit busy,uart_state=0;
  69          uchar wptr=0,temp;
  70          uchar cou_uart=0;
  71          uchar rptr;
  72          uchar  ture_state=0;
  73          uchar buffer[32],Date_Send[3];//接收和发送的数据数组
  74          uchar date_now=0x00,date_last=0x00;
  75          uchar RX_begin=0;RX_finish=0;
  76          uchar date_finish_now=0x00;date_finish_last=0x00;
  77          uchar buffer_begin=0;  //当前帧数据起始位置
  78          
  79          void UartIsr() interrupt 4 using 1
  80          {
  81   1          if (TI)
  82   1          {
  83   2              TI = 0;
  84   2              busy = 0;
  85   2          }
  86   1          if (RI)
  87   1          {
  88   2          RI = 0;
  89   2              date_now = SBUF;
  90   2              if((date_now==0x5a)&&(date_last==0xaa)){    //起始码为  aa   5a
  91   3            RX_begin=1;        //收到起始码
  92   3            buffer_begin=wptr+1;//数据内容第一字节位置
  93   3            }
  94   2          if(RX_begin==1){
  95   3            buffer[wptr]=date_now;
  96   3          }
  97   2          if(wptr>4){
  98   3            date_finish_now=buffer[wptr];date_finish_last=buffer[wptr-1];
  99   3            if((date_finish_now==0xc3)&&(date_finish_last==0xcc)){//结束码  cc  c3
 100   4              RX_begin=0;//结束接收这一帧数据
 101   4              wptr=0; 
 102   4              RX_finish=1;//完成接收一帧数据
 103   4            }
 104   3          }
 105   2          wptr++;
 106   2          if(wptr>30){wptr=0;}
 107   2          date_last=date_now;
 108   2            cou_uart=0;  
 109   2          }
 110   1      }
 111          
 112          void UartInit() //9600bps@24.000MHz
 113          {
 114   1        SCON = 0x50;    //8位数据,可变波特率
 115   1        AUXR |= 0x01;   //串口1选择定时器2为波特率发生器
 116   1        AUXR |= 0x04;   //定时器2时钟为Fosc,即1T
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 3   

 117   1        T2L = 0x8F;   //设定定时初值
 118   1        T2H = 0xFD;   //设定定时初值
 119   1        AUXR |= 0x10;   //启动定时器2
 120   1          wptr = 0x00;
 121   1          rptr = 0x00;
 122   1          busy = 0;
 123   1      }
 124          
 125          void UartSend(char dat)
 126          {
 127   1          while (busy);
 128   1          busy = 1;
 129   1          SBUF = dat;
 130   1      }
 131          
 132          void UartSendStr(char *p)
 133          {
 134   1          while (*p)
 135   1          {
 136   2              UartSend(*p++);
 137   2          }
 138   1      }
 139          /****************************************  EEPROM相关  ***************************************************
             -/
 140          #define WD1 0x5a  
 141          #define WD2 0xa5
 142          
 143          #define ENABLE_ISP 0x82 
 144          typedef unsigned char      INT8U;         
 145          typedef unsigned int   INT16U;
 146          
 147          union union_temp16                               
 148          {
 149              INT16U un_temp16;
 150              INT8U  un_temp8[2];
 151          }my_unTemp16;
 152          
 153          INT8U Byte_Read(INT16U add);             
 154          void Byte_Program(INT16U add, INT8U ch);  
 155          void Sector_Erase(INT16U add);            
 156          void IAP_Disable(); 
 157          uchar first_online=0;  
 158          /*************************************  eeprom保存和读取  ************************************************
             -***/
 159          void eeprom_read(){
 160   1      uchar date_L=0,date_H=0;//数据临时寄存
 161   1        pump_auto_sign  = Byte_Read(0x3501);    //读EEPROM的值
 162   1        mode_state      = Byte_Read(0x3502);    //读EEPROM的值
 163   1        pump_error_time_set = Byte_Read(0x3503);    //读EEPROM的值 
 164   1        date_L          = Byte_Read(0x3504);    
 165   1        date_H          = Byte_Read(0x3505);  
 166   1        DIST_L=date_H;             //低水位阈值数据
 167   1        DIST_L=(DIST_L<<8)+date_L;
 168   1        date_L          = Byte_Read(0x3506);     
 169   1        date_H          = Byte_Read(0x3507);  
 170   1        DIST_H=date_H;             //高水位阈值数据
 171   1        DIST_H=(DIST_H<<8)+date_L;
 172   1        first_online    = Byte_Read(0x3508); //首次上电标志
 173   1      } 
 174          void eeprom_save(){
 175   1      uchar date_L=0,date_H=0;
 176   1        Sector_Erase(0x3501);           //擦除整个扇区
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 4   

 177   1        Byte_Program(0x3501, pump_auto_sign);//抽水前提醒标志
 178   1        Byte_Program(0x3502, mode_state);  //模式 
 179   1        Byte_Program(0x3503, pump_error_time_set);  //异常检测时间
 180   1        date_L=DIST_L;    //分解uint
 181   1        date_H=(DIST_L>>8);
 182   1        Byte_Program(0x3504, date_L);      //低水位阈值数据
 183   1        Byte_Program(0x3505, date_H);
 184   1        date_L=DIST_H;
 185   1        date_H=(DIST_H>>8);
 186   1        Byte_Program(0x3506, date_L);     //高水位阈值数据
 187   1        Byte_Program(0x3507, date_H);
 188   1        Byte_Program(0x3508, 0xab);
 189   1      }
 190          void date_init(){
 191   1        eeprom_read();
 192   1        if(first_online!=0xab){
 193   2          pump_auto_sign=0;
 194   2          mode_state=0;
 195   2          pump_error_time_set=30;
 196   2          DIST_L=600;
 197   2          DIST_H=150;
 198   2          eeprom_save();
 199   2        } 
 200   1      }
 201          /************************************************主进程***************************************************
             -*******************/
 202          void main()
 203          {
 204   1        set_jdy40=1;//透传模式
 205   1        date_init();//数据初始化
 206   1        buzzer_mode(1);//蜂鸣器初始化（静音）
 207   1        P_SW2 = 0x80;//使能访问扩展SFR  //P_SW2 = 0x00;//关闭访问扩展SFR 
 208   1        delay_ms(200);
 209   1        I2C_Init();//I2C总线初始化
 210   1        delay_ms(200);
 211   1        OLED_Init(); //OLED初始化
 212   1        delay_ms(200);
 213   1      
 214   1          Show_Str(48,1,"欢迎",16,0);
 215   1          OLED_P8x16Str(32,4,"WELCOME!");
 216   1        delay_ms(800);OLED_Clear();delay_ms(200); 
 217   1        UartInit();
 218   1          ES = 1;
 219   1          EA = 1;
 220   1        time_init ();
 221   1      
 222   1        while(1)
 223   1        {   
 224   2            delay_ms(20);
 225   2          RecDate();  //处理接收到的数据
 226   2          deal_date();//数据处理
 227   2          state_deal();//状态识别,核心工作逻辑    
 228   2            oled_display(); //显示
 229   2            key_scan();   //按键扫描
 230   2            if(SendDate_count>=10){SendDate_count=0;SendDate();}//x*25ms 发送一次
 231   2      
 232   2        } 
 233   1      }
 234          /*********************************************状态判断，核心逻辑******************************************
             -*********/
 235          void working_auto();   //自动工作模式核心逻辑
 236          void working_manual(); //手动工作模式核心逻辑
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 5   

 237          void pump_error_detect();//抽水异常检测
 238          void state_deal(){                //模式判断
 239   1        if(ruler_online_state==0){
 240   2          message_state=7;//"测量端未连接"
 241   2        }else{
 242   2          if(pump_online_state==0&&mode_state==0){   //水泵控制端未连接且自动模式
 243   3            message_state=3;//"水泵控制器未连接"
 244   3          }else if(pump_online_state==1&&mode_state==0){ //水泵控制端在线且自动模式---正常工作_自动模式
 245   3            working_auto();//自动模式正常工作 
 246   3          }else if(pump_online_state==1&&mode_state==1){ //手动模式 水泵控制器在线 ---提示可使用自动模式
 247   3            message_state=8;//"水泵控制器已连接，可使用自动模式"
 248   3          }else if(pump_online_state==0&&mode_state==1){ //水泵控制端离线 手动模式 ---正常工作_手动模式
 249   3            working_manual();//手动模式正常工作
 250   3          }
 251   2        } 
 252   1      }
 253          void working_auto(){                //自动模式
 254   1        if(DIST_temp>DIST_L){ //水位低于设置水位 
 255   2          if(pump_power==0&&pump_power_real==0){
 256   3            if(pump_auto_sign==0){           //抽水前提醒
 257   4              message_state=6;//"请按[启/停]抽水" 
 258   4              buzzer_mode(2);//蜂鸣器 0-关 1-报警 2-提醒 
 259   4            }else{
 260   4              pump_power=1;     //启动水泵
 261   4            }
 262   3          }else if(pump_power==1&&pump_power_real==0){
 263   3            message_state=9;//"水泵启动中..."
 264   3            buzzer_mode(0);
 265   3          }else if(pump_power==1&&pump_power_real==1){
 266   3      //      message_state=5;//"抽水中..."
 267   3            pump_error_detect();//抽水异常检测
 268   3          }else if(pump_power==0&&pump_power_real==1){
 269   3            message_state=10;//"水泵停止中..."
 270   3            buzzer_mode(0);
 271   3          }
 272   2        }else if((DIST_temp<=DIST_L)&&(DIST_temp>=DIST_H)){ //正常水位
 273   2          buzzer_mode(0);
 274   2          if(pump_power==0&&pump_power_real==0){
 275   3            message_state=1;//"水位正常" 
 276   3          }else if(pump_power==1&&pump_power_real==0){
 277   3            message_state=9;//"水泵启动中..."
 278   3          }else if(pump_power==1&&pump_power_real==1){
 279   3      //      message_state=5;//"抽水中..."
 280   3            pump_error_detect();//抽水异常检测
 281   3          }else if(pump_power==0&&pump_power_real==1){
 282   3            message_state=10;//"水泵停止中..."
 283   3          }   
 284   2        }else if((DIST_temp<DIST_H)){            //水位高
 285   2          pump_power=0;  //关闭水泵
 286   2          if(pump_power==0&&pump_power_real==0){
 287   3            message_state=11;//"水位高"
 288   3            buzzer_mode(0);
 289   3          }else if(pump_power==1&&pump_power_real==0){
 290   3            message_state=9;//"水泵启动中..."
 291   3            buzzer_mode(0);
 292   3          }else if(pump_power==1&&pump_power_real==1){
 293   3            message_state=5;//"抽水中..."
 294   3            buzzer_mode(1);//报警
 295   3          }else if(pump_power==0&&pump_power_real==1){
 296   3            message_state=10;//"水泵停止中..."
 297   3            buzzer_mode(0);
 298   3          } 
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 6   

 299   2        }   
 300   1      }
 301          void working_manual(){                   //手动模式
 302   1        if(DIST_temp>DIST_L){ //水位低于设置水位 
 303   2          if(pump_power==0){
 304   3            buzzer_mode(2);//蜂鸣器 0-关 1-报警 2-提醒 
 305   3            message_state=2;//"水位低"
 306   3          }else{
 307   3      //      message_state=5;//"抽水中..."
 308   3            pump_error_detect();//抽水异常检测
 309   3          }
 310   2          buzzer_off=0;//消音标志  不消音 ---按键消音
 311   2        }else if((DIST_temp<=DIST_L)&&(DIST_temp>=DIST_H)){ //正常水位 
 312   2          if(pump_power==0){
 313   3            buzzer_mode(0);
 314   3            message_state=1;//"水位正常"
 315   3          }else{
 316   3            pump_error_detect();//抽水异常检测   抽水中。。。
 317   3          }
 318   2          buzzer_off=0;//消音标志   
 319   2        }else if((DIST_temp<DIST_H)){            //水位高
 320   2          if(buzzer_off==0){      //未消音
 321   3            buzzer_mode(1);//报警
 322   3            message_state=11;//"水位高"   
 323   3          }else{
 324   3            buzzer_mode(0);//消音
 325   3            message_state=11;//"水位高"     
 326   3          } 
 327   2        }
 328   1      }
 329          void pump_error_detect(){//抽水异常检测  
 330   1        if(pump_error_count>39){//40*25ms=1s  定时器
 331   2          pump_error_count=0;
 332   2          if((DIST_temp+5)<DIST_last){  //水位上升5mm(测量误差3mm)，计时清零
 333   3            pump_error_time=0;     
 334   3          }else{
 335   3            pump_error_time++;    //否则计时加1
 336   3          }
 337   2          DIST_last=DIST_temp;//一秒 更新水位
 338   2        }
 339   1        if(pump_error_time>=pump_error_time_set){  //计时到达设定值
 340   2          buzzer_mode(1);//报警
 341   2          message_state=4;//"水泵异常或水不足"
 342   2        }else{
 343   2          buzzer_mode(0);
 344   2          message_state=5;//"抽水中..."
 345   2        }     
 346   1      }
 347          /*********************************************oled显示界面************************************************
             -***/
 348          void oled_display(void)
 349          {  
 350   1      /**************************************主界面************************************************/    
 351   1        if(menu==1){      
 352   2          if(down_state==1){Show_Str(8,0,"三",16,0);}   //代替“↓”                        //第一行
 353   2          else{Show_Str(8,0,"  ",16,0);}
 354   2          if(ruler_online_state==1){Show_Str(24,0,"四",16,0);}   //代替 超声波图标
 355   2          else{Show_Str(24,0,"  ",16,0);}
 356   2          if(pump_online_state==1){Show_Str(48,0,"六",16,0);}     //代替 水泵图标
 357   2          else{Show_Str(48,0,"  ",16,0);}
 358   2          if(mode_state==1){Show_Str(88,0,"手动",16,0);}      //显示 自动模式 or 手动
 359   2          else{Show_Str(88,0,"自动",16,0);}
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 7   

 360   2        
 361   2          if(message_state==1){                                       //第二行
 362   3            Show_Str_Center(0,2,"    水位真常    ",16,0);   //居中显示  ‘真’代替‘正’
 363   3          }else if(message_state==2){
 364   3            Show_Str_Center(0,2,"     水位低     ",16,0); 
 365   3          }else if(message_state==3){
 366   3            Show_Str_Center(0,2,"水泵控制器未连接",16,0);
 367   3          }else if(message_state==4){
 368   3            Show_Str_Center(0,2,"水泵异常或水不足",16,0);
 369   3          }else if(message_state==5){
 370   3            Show_Str_Center(0,2,"    抽水中...   ",16,0);
 371   3          }else if(message_state==6){
 372   3            Show_Str_Center(0,2,"请按[启/停]抽水 ",16,0);
 373   3          }else if(message_state==7){
 374   3            Show_Str_Center(0,2,"  测量端未连接  ",16,0);
 375   3          }else if(message_state==8){
 376   3            Show_Str_Center(0,2," 可使用自动模式 ",16,0);
 377   3          }else if(message_state==9){
 378   3            Show_Str_Center(0,2," 水泵启动中...  ",16,0);
 379   3          }else if(message_state==10){
 380   3            Show_Str_Center(0,2," 水泵停止中...  ",16,0);
 381   3          }else if(message_state==11){
 382   3            Show_Str_Center(0,2,"     水位高     ",16,0); 
 383   3          }
 384   2        
 385   2          Show_Str(0,4,"实时测距:",16,0);             //第三行
 386   2          if(ruler_online_state==1){
 387   3            OLED_ShowNum(72,4,DIST_temp,4,16,0);//数字，长度
 388   3          }else{
 389   3            Show_Str(72,4," ---",16,0);
 390   3          } 
 391   2          Show_Str(104,4,"mm",16,0);
 392   2        
 393   2          
 394   2          Show_Str(0,6,"设置",16,0);                 //第四行
 395   2          Show_Str(44,6,"启/停",16,0);   
 396   2          Show_Str(95,6,"模式",16,0);
 397   2      /**************************************设置 菜单1************************************************/    
 398   2        }else if(menu==2){  
 399   2          if(set_state==1){                   //第一行
 400   3            Show_Str(0,0,"1. 高水位",16,1);           //反色显示
 401   3            OLED_ShowNum(72,0,DIST_H,4,16,1);//数字，长度
 402   3            Show_Str(104,0,"mm ",16,1); 
 403   3          }else{
 404   3            Show_Str(0,0,"1. 高水位",16,0);
 405   3            OLED_ShowNum(72,0,DIST_H,4,16,0);//数字，长度
 406   3            Show_Str(104,0,"mm ",16,0);   
 407   3          }
 408   2          if(set_state==2){                   //第二行
 409   3            Show_Str(0,2,"2. 低水位",16,1);           
 410   3            OLED_ShowNum(72,2,DIST_L,4,16,1);//数字，长度
 411   3            Show_Str(104,2,"mm ",16,1); 
 412   3          }else{
 413   3            Show_Str(0,2,"2. 低水位",16,0);
 414   3            OLED_ShowNum(72,2,DIST_L,4,16,0);//数字，长度
 415   3            Show_Str(104,2,"mm ",16,0);   
 416   3          }
 417   2          if(set_state==3){                   //第三行
 418   3            Show_Str(0,4,"3. 抽水前提醒 ",16,1);            
 419   3            if(pump_auto_sign==0){Show_Str(112,4,"开",16,1);}else{Show_Str(112,4,"关",16,1);} 
 420   3          }else{
 421   3            Show_Str(0,4,"3. 抽水前提醒 ",16,0);            
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 8   

 422   3            if(pump_auto_sign==0){Show_Str(112,4,"开",16,0);}else{Show_Str(112,4,"关",16,0);}   
 423   3          }
 424   2          Show_Str(8,6,"-",16,0);Show_Str(40,6,"下一项",16,0);Show_Str(112,6,"+",16,0); //第四行
 425   2      /**************************************设置 菜单2************************************************/  
 426   2        }else if(menu==3){
 427   2          if(set_state==1){                   //第一行
 428   3            Show_Str(0,0,"4. 异常检测 ",16,1);      
 429   3            OLED_ShowNum(96,0,pump_error_time_set,2,16,1);//数字，长度
 430   3            Show_Str(112,0,"秒",16,1); 
 431   3          }else{
 432   3            Show_Str(0,0,"4. 异常检测 ",16,0);      
 433   3            OLED_ShowNum(96,0,pump_error_time_set,2,16,0);//数字，长度
 434   3            Show_Str(112,0,"秒",16,0);    
 435   3          }
 436   2          if(set_state==2){                   //第二行
 437   3            Show_Str(0,2,"5. 关  于       ",16,1);            
 438   3          }else{
 439   3            Show_Str(0,2,"5. 关  于       ",16,0);  
 440   3          }
 441   2          if(set_state==3){                   //第三行
 442   3            Show_Str(0,4,"6. 退  出       ",16,1);            
 443   3          }else{
 444   3            Show_Str(0,4,"6. 退  出       ",16,0);  
 445   3          }
 446   2          Show_Str(8,6,"-",16,0);Show_Str(40,6,"下一项",16,0);Show_Str(112,6,"+",16,0); //第四行    
 447   2        }
 448   1      }
 449          /***************************************按键相关******************************************************/
 450          void key_scan(){
 451   1      /*************************************HOME*****************************************/
 452   1        if(menu==1){
 453   2          if(key1==0){    
 454   3            DelayMs(15);
 455   3      //      buzzer_mode(3);//响一声
 456   3            if(key1==0){
 457   4               while(key1==0){Show_Str(0,6,"设置",16,1);}//等待按键松开
 458   4             menu=2; //进入设置菜单
 459   4             buzzer_off=1;//消音
 460   4             OLED_Clear();delay_ms(200);
 461   4            }
 462   3          }
 463   2          if(key2==0){     
 464   3            DelayMs(15);
 465   3            if(key2==0){
 466   4               while(key2==0){Show_Str(44,6,"启/停",16,1);}//等待按键松开
 467   4             pump_power=!pump_power;//水泵启停标志
 468   4             buzzer_off=1;//消音
 469   4            }
 470   3          }
 471   2          if(key3==0){
 472   3            DelayMs(15);
 473   3            if(key3==0){
 474   4              while(key3==0){Show_Str(95,6,"模式",16,1);}
 475   4              mode_state=!mode_state;
 476   4              pump_power=0;//切换模式后 水泵标志清零
 477   4              buzzer_off=1;//消音
 478   4              eeprom_save();
 479   4            }
 480   3          }
 481   2      /************************************SET_1*************************************/
 482   2        }else if(menu==2){
 483   2          if(set_state==1){   //高水位
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 9   

 484   3            if(key1==0){     
 485   4              DelayMs(15);
 486   4              if(key1==0){   //-
 487   5                 while(key1==0){Show_Str(8,6,"-",16,1);}//等待按键松开
 488   5               DIST_H-=10;if(DIST_H<=50){DIST_H=50;}
 489   5              }
 490   4            }
 491   3            if(key2==0){    
 492   4              DelayMs(15);
 493   4              if(key2==0){
 494   5                 while(key2==0){Show_Str(40,6,"下一项",16,1);}//等待按键松开
 495   5               set_state=2;//切换下一项
 496   5              }
 497   4            }
 498   3            if(key3==0){
 499   4              DelayMs(15);
 500   4              if(key3==0){
 501   5                while(key3==0){Show_Str(112,6,"+",16,1);}
 502   5                DIST_H+=10;if(DIST_H>=DIST_L){DIST_H=DIST_L-10;}
 503   5              }
 504   4            }
 505   3          }
 506   2          if(set_state==2){    //低水位
 507   3            if(key1==0){     
 508   4              DelayMs(15);
 509   4              if(key1==0){   //-
 510   5                 while(key1==0){Show_Str(8,6,"-",16,1);}//等待按键松开
 511   5               DIST_L-=10;if(DIST_L<=DIST_H){DIST_L=DIST_H+10;}
 512   5              }
 513   4            }
 514   3            if(key2==0){    
 515   4              DelayMs(15);
 516   4              if(key2==0){
 517   5                 while(key2==0){Show_Str(40,6,"下一项",16,1);}//等待按键松开
 518   5               set_state=3;//切换下一项
 519   5              }
 520   4            }
 521   3            if(key3==0){
 522   4              DelayMs(15);
 523   4              if(key3==0){
 524   5                while(key3==0){Show_Str(112,6,"+",16,1);}
 525   5                DIST_L+=10;if(DIST_L>=2500){DIST_L=2500;}
 526   5              }
 527   4            }
 528   3          }
 529   2          if(set_state==3){   //抽水前提醒
 530   3            if(key1==0){     
 531   4              DelayMs(15);
 532   4              if(key1==0){   //-
 533   5                 while(key1==0){Show_Str(8,6,"-",16,1);}//等待按键松开
 534   5               pump_auto_sign=!pump_auto_sign;
 535   5              }
 536   4            }
 537   3            if(key2==0){    
 538   4              DelayMs(15);
 539   4              if(key2==0){
 540   5                 while(key2==0){Show_Str(40,6,"下一项",16,1);}//等待按键松开
 541   5               set_state=1;//切换下一项
 542   5               menu=3;OLED_Clear();delay_ms(200);
 543   5              }
 544   4            }
 545   3            if(key3==0){
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 10  

 546   4              DelayMs(15);
 547   4              if(key3==0){
 548   5                while(key3==0){Show_Str(112,6,"+",16,1);}
 549   5                pump_auto_sign=!pump_auto_sign;
 550   5              }
 551   4            }
 552   3          }   
 553   2      /************************************SET_2***************************************/
 554   2        }else if(menu==3){     //异常检测时间
 555   2          if(set_state==1){
 556   3            if(key1==0){     
 557   4              DelayMs(15);
 558   4              if(key1==0){   //-
 559   5                 while(key1==0){Show_Str(8,6,"-",16,1);}//等待按键松开
 560   5               pump_error_time_set--;if(pump_error_time_set>100){pump_error_time_set=0;}
 561   5              }
 562   4            }
 563   3            if(key2==0){    
 564   4              DelayMs(15);
 565   4              if(key2==0){
 566   5                 while(key2==0){Show_Str(40,6,"下一项",16,1);}//等待按键松开
 567   5               set_state=2;//切换下一项
 568   5              }
 569   4            }
 570   3            if(key3==0){
 571   4              DelayMs(15);
 572   4              if(key3==0){
 573   5                while(key3==0){Show_Str(112,6,"+",16,1);}
 574   5                pump_error_time_set++;if(pump_error_time_set>99){pump_error_time_set=99;}
 575   5              }
 576   4            }
 577   3          }
 578   2          if(set_state==2){       //关于
 579   3            if(key1==0){     
 580   4              DelayMs(15);
 581   4              if(key1==0){   //-
 582   5                 while(key1==0){Show_Str(8,6,"-",16,1);}//等待按键松开
 583   5            
 584   5              }
 585   4            }
 586   3            if(key2==0){    
 587   4              DelayMs(15);
 588   4              if(key2==0){
 589   5                 while(key2==0){Show_Str(40,6,"下一项",16,1);}//等待按键松开
 590   5               set_state=3;//切换下一项
 591   5              }
 592   4            }
 593   3            if(key3==0){
 594   4              DelayMs(15);
 595   4              if(key3==0){
 596   5                while(key3==0){Show_Str(112,6,"+",16,1);}
 597   5              
 598   5              }
 599   4            }
 600   3          }
 601   2          if(set_state==3){   //退出
 602   3            if(key1==0){     
 603   4              DelayMs(15);
 604   4              if(key1==0){   //-
 605   5                 while(key1==0){Show_Str(8,6,"-",16,1);}//等待按键松开
 606   5               menu=1;set_state=1;OLED_Clear();delay_ms(200);eeprom_save();
 607   5              }
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 11  

 608   4            }
 609   3            if(key2==0){    
 610   4              DelayMs(15);
 611   4              if(key2==0){
 612   5                 while(key2==0){Show_Str(40,6,"下一项",16,1);}//等待按键松开
 613   5               set_state=1;//切换下一项
 614   5               menu=2;OLED_Clear();delay_ms(200);
 615   5              }
 616   4            }
 617   3            if(key3==0){
 618   4              DelayMs(15);
 619   4              if(key3==0){
 620   5                while(key3==0){Show_Str(112,6,"+",16,1);}
 621   5                menu=1;set_state=1;OLED_Clear();delay_ms(200);eeprom_save();
 622   5              }
 623   4            }
 624   3          }     
 625   2        }
 626   1      
 627   1      }
 628          /***************************************蜂鸣器******************************************************/
 629          void buzzer_mode(uchar buz_mode){//  0-关 1-报警 2-提醒  3-响一声   定时器： buzzer_count  25ms
 630   1        if(buz_mode==0){       //关
 631   2          buzzer=1;
 632   2          buzzer_step=1;
 633   2        }else if(buz_mode==1){     //报警
 634   2          if(buzzer_count>19){   //间隔20*25ms=500ms
 635   3            buzzer=!buzzer;
 636   3            buzzer_count=0;
 637   3          }
 638   2        }else if(buz_mode==2){      //提醒
 639   2          if(buzzer_step==1){
 640   3            buzzer=1;
 641   3            buzzer_step=2;
 642   3          }else if(buzzer_step==2){
 643   3            buzzer=0;
 644   3            buzzer_step=3;
 645   3            buzzer_count=0;
 646   3          }else if(buzzer_step==3&&buzzer_count>11){ //12*25ms 响 300ms
 647   3            buzzer=1;
 648   3            buzzer_step=4;
 649   3            buzzer_count=0;
 650   3          }else if(buzzer_step==4&&buzzer_count>59){  //60*25ms  静音1500ms
 651   3            buzzer_step=1;    
 652   3          }
 653   2        }else if(buz_mode==3){    //响一声
 654   2          buzzer=0;
 655   2          delay_ms(100);
 656   2          buzzer=1;
 657   2        }
 658   1      }
 659          /*****************************************发送数据、接收数据处理******************************************
             -*****************/
 660          void SendDate(){
 661   1        uchar a,b;
 662   1        if(menu==1){Show_Str(0,0,"↑",16,0);}
 663   1        if(send_add==0){      //发送给测量端
 664   2            Date_Send[0]=0xab;   //本设备地址AB
 665   2          Date_Send[1]=0xcd;   //目标设备地址
 666   2          Date_Send[2]=0x00;  
 667   2        }else if(send_add==1){    //发送给水泵控制器
 668   2            Date_Send[0]=0xab;    
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 12  

 669   2          Date_Send[1]=0xef;    //目标设备地址
 670   2          Date_Send[2]=pump_power;
 671   2        }
 672   1        UartSend(0xaa);//起始码
 673   1          UartSend(0x5a);
 674   1        for(b=0;b<3;b++){     //发送三遍
 675   2            for (a=0; a<3; a++)
 676   2            {
 677   3               UartSend(Date_Send[a]);
 678   3            }
 679   2        }
 680   1        UartSend(0xcc);//结束码
 681   1        UartSend(0xc3); 
 682   1        DelayMs(15);
 683   1        send_add=!send_add; //切换当前通讯设备
 684   1        if(menu==1){Show_Str(0,0,"  ",16,0);}     
 685   1      }
 686          void RecDate(){
 687   1      uchar i=0;
 688   1      i=buffer_begin;
 689   1        if(RX_finish==1){
 690   2           //重复校验
 691   2           if(buffer[i]==buffer[i+3]&&buffer[i]==buffer[i+6]&&buffer[i+1]==buffer[i+4]&&buffer[i+1]==buffer[i+7]&
             -&buffer[i+2]==buffer[i+5]&&buffer[i+2]==buffer[i+8])//校验无误
 692   2           {
 693   3              test=!test;
 694   3            down_state=1; //显示“↓”标志 
 695   3            add=buffer[i];
 696   3              if(add==0xcd){      //若第一位数据为 0xcd则为测量端传来  0xef 为水泵控制端
 697   4              DIST[0]=buffer[i+1];      //超声波测距数据
 698   4              DIST[1]=buffer[i+2];
 699   4                  ruler_online_state=1;   //显示超声波图标
 700   4                ruler_online_time=0;//显示超声波图标  计时    如果收到一次数据则认为已经连接      
 701   4            }else if(add==0xef){
 702   4                pump_power_real=buffer[i+1];//水泵实际状态回传
 703   4                pump_online_state=1;   //显示水泵在线图标
 704   4              pump_online_time=0;   //水泵在线图标  计时
 705   4            }   
 706   3           }
 707   2           wptr=0;
 708   2           RX_finish=0; //串口收到数据标志 清零 等待下次接收到数据
 709   2         }
 710   1      }
 711          void deal_date(){  //数据处理
 712   1        DIST_temp=DIST[1];           //合并测距数据 精度mm
 713   1        DIST_temp=(DIST_temp<<8)+DIST[0];   
 714   1      //  water_height=pot_height-DIST_temp;  //计算水位高度
 715   1      //  water_height_score=(float)((float)water_height*100)/pot_height; //计算水位百分比
 716   1        
 717   1      }
 718          /******************************************定时器初始化***************************************************
             -****/
 719          void time_init (void){            
 720   1        TMOD = 0x11;         // 定时/计数器0,1工作于方式1     
 721   1          TH0 = 0x3c;          // 预置产生25ms时基信号   
 722   1          TL0 = 0xb0;   
 723   1          EA = 1;              // 开总中断   
 724   1          ET0 = 1;             // 定时/计数器0允许中断   
 725   1          TR0 = 1;             // 开闭定时/计数器0   
 726   1      }
 727          /*****************************************中断处理程序**********************************************/ 
 728          void tiem0(void) interrupt 1{   // T/C0中断服务程序(产生25ms时基信号)   
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 13  

 729   1          cou++;       // 软计数器加1
 730   1                             
 731   1        SendDate_count++;          //发送数据 延时计时 
 732   1        if(SendDate_count>200){SendDate_count=0;} 
 733   1      
 734   1        cou_uart++;          //串口 超过0.5秒没接收完数据则从头开始
 735   1        if(cou_uart>=100){wptr=0;}
 736   1      
 737   1        buzzer_count++;
 738   1        if(buzzer_count>20000){buzzer_count=0;}
 739   1      
 740   1        ruler_online_time++;    
 741   1        if(ruler_online_time>160){ruler_online_state=0;}//4秒无信号认为超声波断开
 742   1        pump_online_time++;   
 743   1        if(pump_online_time>160){pump_online_state=0;}//4秒无信号认为 水泵 断开
 744   1      
 745   1        down_state_time++;if(down_state_time>12){down_state=0;}//0.3秒“↓”消失
 746   1      
 747   1        pump_error_count++;                 //水泵异常检测 时基
 748   1        if(pump_error_count>20000){pump_error_count=0;}
 749   1      
 750   1          if(cou > 39){                 // 40*25=1000ms(1s)   
 751   2              cou = 0;               // 软计数器清零   
 752   2              sec++;                 // 秒计数器加1(进位10ms*100=1s) 
 753   2      //    send_add=!send_add; //切换当前通讯设备
 754   2           if(sec > 59){          // 秒计数值到60    
 755   3                  sec = 0;           // 秒计数器清零   
 756   3                  min++;             // 分计数器加1(进位60s=1m)  
 757   3            if(min>59){min=0;}
 758   3              }
 759   2        
 760   2          }   
 761   1          TH0 = 0x3c;                // 定时器重装  
 762   1          TL0 = 0xb0;   
 763   1      }
 764          /********************************  EEPORM相关  ************************************************/
 765          /*********************************  读一字节  *************************************************/
 766          //读一字节，调用前需打开IAP 功能，入口:DPTR = 字节地址，返回:A = 读出字节
 767          INT8U Byte_Read(INT16U add)
 768          {
 769   1          IAP_DATA = 0x00;
 770   1          IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
 771   1          IAP_CMD = 0x01;                 //IAP/ISP/EEPROM 字节读命令
 772   1      
 773   1          my_unTemp16.un_temp16 = add;
 774   1          IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
 775   1          IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
 776   1      
 777   1          //EA = 0;
 778   1          IAP_TRIG = WD1;   //先送 WD1,再送WD2 到ISP/IAP 触发寄存器,每次都需如此
 779   1          IAP_TRIG = WD2;   //送完WD2 后，ISP/IAP 命令立即被触发起动
 780   1          _nop_();
 781   1          //EA = 1;
 782   1          IAP_Disable();  //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态,
 783   1                          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
 784   1          return (IAP_DATA);
 785   1      }
 786          /*******************************  字节编程  ********************************************************/
 787          //字节编程，调用前需打开IAP 功能，入口:DPTR = 字节地址, A= 须编程字节的数据
 788          void Byte_Program(INT16U add, INT8U ch)
 789          {
 790   1          IAP_CONTR = ENABLE_ISP;         //打开 IAP 功能, 设置Flash 操作等待时间
C51 COMPILER V9.60.0.0   MAIN                                                              10/21/2021 19:57:23 PAGE 14  

 791   1          IAP_CMD = 0x02;                 //IAP/ISP/EEPROM 字节编程命令
 792   1      
 793   1          my_unTemp16.un_temp16 = add;
 794   1          IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
 795   1          IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
 796   1      
 797   1          IAP_DATA = ch;                  //要编程的数据先送进IAP_DATA 寄存器
 798   1          //EA = 0;
 799   1          IAP_TRIG = WD1;   //先送 WD1,再送WD2 到ISP/IAP 触发寄存器,每次都需如此
 800   1          IAP_TRIG = WD2;   //送完WD2 后，ISP/IAP 命令立即被触发起动
 801   1          _nop_();
 802   1          //EA = 1;
 803   1          IAP_Disable();  //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态,
 804   1                          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
 805   1      }
 806          /***************************************  擦除扇区  ************************************************/
 807          //擦除扇区, 入口:DPTR = 扇区地址
 808          void Sector_Erase(INT16U add)
 809          {
 810   1          IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
 811   1          IAP_CMD = 0x03;                 //IAP/ISP/EEPROM 扇区擦除命令
 812   1      
 813   1          my_unTemp16.un_temp16 = add;
 814   1          IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
 815   1          IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
 816   1      
 817   1          //EA = 0;
 818   1          IAP_TRIG = WD1;   //先送 WD1,再送WD2 到ISP/IAP 触发寄存器,每次都需如此
 819   1          IAP_TRIG = WD2;   //送完WD2 后，ISP/IAP 命令立即被触发起动
 820   1          _nop_();
 821   1          //EA = 1;
 822   1          IAP_Disable();  //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态,
 823   1                          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
 824   1      }
 825          /*************************************  关闭IAP 功能  ********************************************/
 826          void IAP_Disable()
 827          {
 828   1          //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态,
 829   1          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
 830   1          IAP_CONTR = 0;      //关闭IAP 功能
 831   1          IAP_CMD   = 0;      //清命令寄存器,使命令寄存器无命令,此句可不用
 832   1          IAP_TRIG  = 0;      //清命令触发寄存器,使命令触发寄存器无触发,此句可不用
 833   1          IAP_ADDRH = 0;
 834   1          IAP_ADDRL = 0;
 835   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5445    ----
   CONSTANT SIZE    =    365    ----
   XDATA SIZE       =     97       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
